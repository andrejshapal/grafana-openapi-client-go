// Code generated by go-swagger; DO NOT EDIT.

package provisioning

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command
// To edit this file, edit the custom template in templates/clientClient.gotmpl
// More info on custom templates can be found in the README or here: https://github.com/go-swagger/go-swagger/blob/master/docs/generate/templates.md
// The template itself can be found here: https://github.com/go-swagger/go-swagger/blob/master/generator/templates/client/client.gotmpl

import (
	"fmt"
	"time"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/grafana/grafana-openapi-client-go/utils"
)

// New creates a new provisioning API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, cfg *utils.ClientConfig) ClientService {
	return &Client{transport: transport, formats: formats, cfg: cfg}
}

/*
Client for provisioning API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	cfg       *utils.ClientConfig
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	RouteDeleteAlertRule(params *RouteDeleteAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteAlertRuleNoContent, error)

	RouteDeleteContactpoints(params *RouteDeleteContactpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteContactpointsNoContent, error)

	RouteDeleteMuteTiming(params *RouteDeleteMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteMuteTimingNoContent, error)

	RouteDeleteTemplate(params *RouteDeleteTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteTemplateNoContent, error)

	RouteGetAlertRule(params *RouteGetAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleOK, error)

	RouteGetAlertRuleExport(params *RouteGetAlertRuleExportParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleExportOK, error)

	RouteGetAlertRuleGroup(params *RouteGetAlertRuleGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleGroupOK, error)

	RouteGetAlertRuleGroupExport(params *RouteGetAlertRuleGroupExportParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleGroupExportOK, error)

	RouteGetAlertRules(params *RouteGetAlertRulesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRulesOK, error)

	RouteGetAlertRulesExport(params *RouteGetAlertRulesExportParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRulesExportOK, error)

	RouteGetContactpoints(params *RouteGetContactpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetContactpointsOK, error)

	RouteGetMuteTiming(params *RouteGetMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetMuteTimingOK, error)

	RouteGetMuteTimings(params *RouteGetMuteTimingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetMuteTimingsOK, error)

	RouteGetPolicyTree(params *RouteGetPolicyTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetPolicyTreeOK, error)

	RouteGetTemplate(params *RouteGetTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetTemplateOK, error)

	RouteGetTemplates(params *RouteGetTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetTemplatesOK, error)

	RoutePostAlertRule(params *RoutePostAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePostAlertRuleCreated, error)

	RoutePostContactpoints(params *RoutePostContactpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePostContactpointsAccepted, error)

	RoutePostMuteTiming(params *RoutePostMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePostMuteTimingCreated, error)

	RoutePutAlertRule(params *RoutePutAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutAlertRuleOK, error)

	RoutePutAlertRuleGroup(params *RoutePutAlertRuleGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutAlertRuleGroupOK, error)

	RoutePutContactpoint(params *RoutePutContactpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutContactpointAccepted, error)

	RoutePutMuteTiming(params *RoutePutMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutMuteTimingOK, error)

	RoutePutPolicyTree(params *RoutePutPolicyTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutPolicyTreeAccepted, error)

	RoutePutTemplate(params *RoutePutTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutTemplateAccepted, error)

	RouteResetPolicyTree(params *RouteResetPolicyTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteResetPolicyTreeAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
RouteDeleteAlertRule deletes a specific alert rule by UID
*/
func (a *Client) RouteDeleteAlertRule(params *RouteDeleteAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteAlertRuleNoContent, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteDeleteAlertRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteDeleteAlertRule",
		Method:             "DELETE",
		PathPattern:        "/api/v1/provisioning/alert-rules/{UID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteDeleteAlertRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteDeleteAlertRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteDeleteAlertRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteDeleteContactpoints deletes a contact point
*/
func (a *Client) RouteDeleteContactpoints(params *RouteDeleteContactpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteContactpointsNoContent, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteDeleteContactpointsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteDeleteContactpoints",
		Method:             "DELETE",
		PathPattern:        "/api/v1/provisioning/contact-points/{UID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteDeleteContactpointsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteDeleteContactpointsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteDeleteContactpoints: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteDeleteMuteTiming deletes a mute timing
*/
func (a *Client) RouteDeleteMuteTiming(params *RouteDeleteMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteMuteTimingNoContent, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteDeleteMuteTimingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteDeleteMuteTiming",
		Method:             "DELETE",
		PathPattern:        "/api/v1/provisioning/mute-timings/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteDeleteMuteTimingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteDeleteMuteTimingNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteDeleteMuteTiming: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteDeleteTemplate deletes a template
*/
func (a *Client) RouteDeleteTemplate(params *RouteDeleteTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteDeleteTemplateNoContent, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteDeleteTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteDeleteTemplate",
		Method:             "DELETE",
		PathPattern:        "/api/v1/provisioning/templates/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteDeleteTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteDeleteTemplateNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteDeleteTemplate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetAlertRule gets a specific alert rule by UID
*/
func (a *Client) RouteGetAlertRule(params *RouteGetAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetAlertRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetAlertRule",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/alert-rules/{UID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetAlertRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetAlertRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetAlertRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetAlertRuleExport exports an alert rule in provisioning file format
*/
func (a *Client) RouteGetAlertRuleExport(params *RouteGetAlertRuleExportParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleExportOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetAlertRuleExportParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetAlertRuleExport",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/alert-rules/{UID}/export",
		ProducesMediaTypes: []string{"application/json", "application/yaml", "text/yaml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetAlertRuleExportReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetAlertRuleExportOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetAlertRuleExport: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetAlertRuleGroup gets a rule group
*/
func (a *Client) RouteGetAlertRuleGroup(params *RouteGetAlertRuleGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleGroupOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetAlertRuleGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetAlertRuleGroup",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetAlertRuleGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetAlertRuleGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetAlertRuleGroup: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetAlertRuleGroupExport exports an alert rule group in provisioning file format
*/
func (a *Client) RouteGetAlertRuleGroupExport(params *RouteGetAlertRuleGroupExportParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRuleGroupExportOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetAlertRuleGroupExportParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetAlertRuleGroupExport",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export",
		ProducesMediaTypes: []string{"application/json", "application/yaml", "text/yaml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetAlertRuleGroupExportReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetAlertRuleGroupExportOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetAlertRuleGroupExport: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetAlertRules gets all the alert rules
*/
func (a *Client) RouteGetAlertRules(params *RouteGetAlertRulesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRulesOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetAlertRulesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetAlertRules",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/alert-rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetAlertRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetAlertRulesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetAlertRules: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetAlertRulesExport exports all alert rules in provisioning file format
*/
func (a *Client) RouteGetAlertRulesExport(params *RouteGetAlertRulesExportParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetAlertRulesExportOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetAlertRulesExportParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetAlertRulesExport",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/alert-rules/export",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetAlertRulesExportReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetAlertRulesExportOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetAlertRulesExport: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetContactpoints gets all the contact points
*/
func (a *Client) RouteGetContactpoints(params *RouteGetContactpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetContactpointsOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetContactpointsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetContactpoints",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/contact-points",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetContactpointsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetContactpointsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetContactpoints: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetMuteTiming gets a mute timing
*/
func (a *Client) RouteGetMuteTiming(params *RouteGetMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetMuteTimingOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetMuteTimingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetMuteTiming",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/mute-timings/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetMuteTimingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetMuteTimingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetMuteTiming: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetMuteTimings gets all the mute timings
*/
func (a *Client) RouteGetMuteTimings(params *RouteGetMuteTimingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetMuteTimingsOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetMuteTimingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetMuteTimings",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/mute-timings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetMuteTimingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetMuteTimingsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetMuteTimings: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetPolicyTree gets the notification policy tree
*/
func (a *Client) RouteGetPolicyTree(params *RouteGetPolicyTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetPolicyTreeOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetPolicyTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetPolicyTree",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetPolicyTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetPolicyTreeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetPolicyTree: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetTemplate gets a notification template
*/
func (a *Client) RouteGetTemplate(params *RouteGetTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetTemplateOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetTemplate",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/templates/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetTemplateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetTemplate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteGetTemplates gets all notification templates
*/
func (a *Client) RouteGetTemplates(params *RouteGetTemplatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteGetTemplatesOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteGetTemplatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteGetTemplates",
		Method:             "GET",
		PathPattern:        "/api/v1/provisioning/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteGetTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteGetTemplatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteGetTemplates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePostAlertRule creates a new alert rule
*/
func (a *Client) RoutePostAlertRule(params *RoutePostAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePostAlertRuleCreated, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePostAlertRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePostAlertRule",
		Method:             "POST",
		PathPattern:        "/api/v1/provisioning/alert-rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePostAlertRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePostAlertRuleCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePostAlertRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePostContactpoints creates a contact point
*/
func (a *Client) RoutePostContactpoints(params *RoutePostContactpointsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePostContactpointsAccepted, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePostContactpointsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePostContactpoints",
		Method:             "POST",
		PathPattern:        "/api/v1/provisioning/contact-points",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePostContactpointsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePostContactpointsAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePostContactpoints: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePostMuteTiming creates a new mute timing
*/
func (a *Client) RoutePostMuteTiming(params *RoutePostMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePostMuteTimingCreated, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePostMuteTimingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePostMuteTiming",
		Method:             "POST",
		PathPattern:        "/api/v1/provisioning/mute-timings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePostMuteTimingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePostMuteTimingCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePostMuteTiming: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePutAlertRule updates an existing alert rule
*/
func (a *Client) RoutePutAlertRule(params *RoutePutAlertRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutAlertRuleOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePutAlertRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePutAlertRule",
		Method:             "PUT",
		PathPattern:        "/api/v1/provisioning/alert-rules/{UID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePutAlertRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePutAlertRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePutAlertRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePutAlertRuleGroup updates the interval of a rule group
*/
func (a *Client) RoutePutAlertRuleGroup(params *RoutePutAlertRuleGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutAlertRuleGroupOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePutAlertRuleGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePutAlertRuleGroup",
		Method:             "PUT",
		PathPattern:        "/api/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePutAlertRuleGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePutAlertRuleGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePutAlertRuleGroup: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePutContactpoint updates an existing contact point
*/
func (a *Client) RoutePutContactpoint(params *RoutePutContactpointParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutContactpointAccepted, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePutContactpointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePutContactpoint",
		Method:             "PUT",
		PathPattern:        "/api/v1/provisioning/contact-points/{UID}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePutContactpointReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePutContactpointAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePutContactpoint: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePutMuteTiming replaces an existing mute timing
*/
func (a *Client) RoutePutMuteTiming(params *RoutePutMuteTimingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutMuteTimingOK, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePutMuteTimingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePutMuteTiming",
		Method:             "PUT",
		PathPattern:        "/api/v1/provisioning/mute-timings/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePutMuteTimingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePutMuteTimingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePutMuteTiming: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePutPolicyTree sets the notification policy tree
*/
func (a *Client) RoutePutPolicyTree(params *RoutePutPolicyTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutPolicyTreeAccepted, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePutPolicyTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePutPolicyTree",
		Method:             "PUT",
		PathPattern:        "/api/v1/provisioning/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePutPolicyTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePutPolicyTreeAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePutPolicyTree: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RoutePutTemplate updates an existing notification template
*/
func (a *Client) RoutePutTemplate(params *RoutePutTemplateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RoutePutTemplateAccepted, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoutePutTemplateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RoutePutTemplate",
		Method:             "PUT",
		PathPattern:        "/api/v1/provisioning/templates/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RoutePutTemplateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RoutePutTemplateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RoutePutTemplate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RouteResetPolicyTree clears the notification policy tree
*/
func (a *Client) RouteResetPolicyTree(params *RouteResetPolicyTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RouteResetPolicyTreeAccepted, error) {
	var (
		result interface{}
		err    error
	)
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRouteResetPolicyTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RouteResetPolicyTree",
		Method:             "DELETE",
		PathPattern:        "/api/v1/provisioning/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RouteResetPolicyTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	timeout := utils.GetTimeout(a.cfg.RetryTimeout)
	for n := 0; n <= a.cfg.NumRetries; n++ {
		// Wait a bit if it is not the first request
		if n != 0 {
			time.Sleep(timeout)
		}

		result, err = a.transport.Submit(op)

		// If err is not nil, retry again
		// That's either caused by client policy, or failure to speak HTTP (such as network connectivity problem). A
		// non-2xx status code doesn't cause an error.
		if err != nil {
			continue
		}

		shouldRetry, err := utils.MatchRetryCode(err, a.cfg.RetryStatusCodes)
		if err != nil {
			return nil, err
		}
		if !shouldRetry {
			break
		}
	}
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RouteResetPolicyTreeAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RouteResetPolicyTree: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
